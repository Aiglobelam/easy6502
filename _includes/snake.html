{% include start.html %}
;  ___           _        __ ___  __ ___
; / __|_ _  __ _| |_____ / /| __|/  \_  )
; \__ \ ' \/ _` | / / -_) _ \__ \ () / /
; |___/_||_\__,_|_\_\___\___/___/\__/___|

; Change direction: W A S D

define appleL    $00 ; screen location of apple
define appleH    $01
define headL     $10 ; screen location of snake head
define headH     $11
define body      $12 ; snake body (in byte pairs)
define direction $02 ; direction (values are below)
define length    $03 ; snake length

; Directions (each using a separate bit)
define movingUp     #1
define movingRight  #2
define movingDown   #4
define movingLeft   #8

; ASCII values of keys controlling the snake
define ASCII_w   #$77
define ASCII_a   #$61
define ASCII_s   #$73
define ASCII_d   #$64

; System variables
define random    $fe
define lastKey   $ff
define screen    $200


  jsr init
  jsr loop

init:
  jsr initSnake
  jsr generateApplePosition
  rts


initSnake:
  lda {movingRight}  ;start direction
  sta {direction}

  lda #4  ;start length (2 segments)
  sta {length}
  
  lda #$11
  sta {headL}
  
  lda #$10
  sta {body}
  
  lda #$0f
  sta $14 ; body segment 1
  
  lda #$04
  sta {headH}
  sta $13 ; body segment 1
  sta $15 ; body segment 2
  rts


generateApplePosition:
  ;load a new random byte into $00
  lda {random}
  sta {appleL}

  ;load a new random number from 2 to 5 into $01
  lda {random}
  and #$03 ;mask out lowest 2 bits
  clc
  adc #2
  sta {appleH}

  rts


loop:
  jsr readKeys
  jsr checkCollision
  jsr updateSnake
  jsr drawApple
  jsr drawSnake
  jsr spinWheels
  jmp loop


readKeys:
  lda {lastKey}
  cmp {ASCII_w}
  beq upKey
  cmp {ASCII_d}
  beq rightKey
  cmp {ASCII_s}
  beq downKey
  cmp {ASCII_a}
  beq leftKey
  rts
upKey:
  lda {movingDown}
  bit {direction}
  bne illegalMove

  lda {movingUp}
  sta {direction}
  rts
rightKey:
  lda {movingLeft}
  bit {direction}
  bne illegalMove

  lda {movingRight}
  sta {direction}
  rts
downKey:
  lda {movingUp}
  bit {direction}
  bne illegalMove

  lda {movingDown}
  sta {direction}
  rts
leftKey:
  lda {movingRight}
  bit {direction}
  bne illegalMove

  lda {movingLeft}
  sta {direction}
  rts
illegalMove:
  rts


checkCollision:
  jsr checkAppleCollision
  jsr checkSnakeCollision
  rts


checkAppleCollision:
  lda {appleL}
  cmp {headL}
  bne doneCheckingAppleCollision
  lda {appleH}
  cmp {headH}
  bne doneCheckingAppleCollision

  ;eat apple
  inc {length}
  inc {length} ;increase length
  jsr generateApplePosition
doneCheckingAppleCollision:
  rts


checkSnakeCollision:
  ldx #2 ;start with second segment
snakeCollisionLoop:
  lda {headL},x
  cmp {headL}
  bne continueCollisionLoop

maybeCollided:
  lda {headH},x
  cmp {headH}
  beq didCollide

continueCollisionLoop:
  inx
  inx
  cpx {length}          ;got to last section with no collision
  beq didntCollide
  jmp snakeCollisionLoop

didCollide:
  jmp gameOver
didntCollide:
  rts


updateSnake:
  ldx {length} ;location of length
  dex
  txa
updateloop:
  lda {headL},x
  sta {body},x
  dex
  bpl updateloop

  lda {direction}
  lsr
  bcs up
  lsr
  bcs right
  lsr
  bcs down
  lsr
  bcs left
up:
  lda {headL}
  sec
  sbc #$20
  sta {headL}
  bcc upup
  rts
upup:
  dec {headH}
  lda #$1
  cmp {headH}
  beq collision
  rts
right:
  inc {headL}
  lda #$1f
  bit {headL}
  beq collision
  rts
down:
  lda {headL}
  clc
  adc #$20
  sta {headL}
  bcs downdown
  rts
downdown:
  inc {headH}
  lda #$6
  cmp {headH}
  beq collision
  rts
left:
  dec {headL}
  lda {headL}
  and #$1f
  cmp #$1f
  beq collision
  rts
collision:
  jmp gameOver


drawApple:
  ldy #0
  lda {random}
  sta ({appleL}),y
  rts


drawSnake:
  ldx #0
  lda #1
  sta ({headL},x) ; paint head
  
  ldx {length}
  lda #0
  sta ({headL},x) ; erase end of tail
  rts


spinWheels:
  ldx #0
spinloop:
  nop
  nop
  dex
  bne spinloop
  rts


gameOver:
{% include end.html %}
